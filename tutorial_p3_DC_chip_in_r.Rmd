---
title: "tutorial_p3_DC_chip_in_r"
author: "Christa Toenhake"
date: "10/21/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r setup-libs, eval = F}
required_packages <- c("GenomicRanges", "rtracklayer", "plyranges", "HelloRangesData", "AnnotationHub", "GenomicFeatures", "UpSetR", "ChIPpeakAnno", "GenomicAlignments" , "DiffBind", "DESeq2")


BiocManager::install(required_packages)
BiocManager::install("DESeq2")

library(GenomicRanges) # to store genomics data in GRanges objects, one of the most important data structures in Bioconductor
library(rtracklayer) # to import bed files in r
library(plyranges) # grammar that extends dplyr from tidyverse package to work with complexity of genomics data and manipulate GRanges objects
library(IRanges) # basic ranges infrastructure 
library(HelloRangesData) # to perform calculations with (mostly) annotation tracks, 'mirror' of bedtools “command line” package run on UNIX, LINUX and Apple OS X 
library(GenomicAlignments) # to import and work with bam files in r
library(DiffBind) # to compare ChIP-seq samples and find differential binding  
library(DESeq2)
```


Notes from DataCamp course **chip-seq with bioconductor in r**  

- reads are stores in a GAlignments object. This object is closely realted to GenmicRanges.  

*Reads are scattered all across the genome, but locations bound by the protein of interest will attract many overlapping reads, leading to peaks in coverage. These peaks are typically recorded with their genomic coordinates as well as a score that indicates the strength of the signal observed for this peak. The peak calls are stored in a GenomicRanges object called peaks. In addition to the usual functions to access the content of GenomicRanges objects, two convenience functions are available for peak calls. You can use the chrom function to obtain the chromosome a peak is located on and the score function to obtain its score.*  

# Ch1 Introduction to ChIP-seq
## 1.1 Video: Intro
### loading BAM files:   
`library(GenomicAlignments)`  
`reads <- readGAlignments('file_name')`  

###  obtaining read coordinates:  
`seqnames(reads)`  # obtain mapping location  
`start(reads)`  # access start location of where the read is mapped to  
`end(reads)`  # access end location of where the read is mapped to    

### Compuating coverage:  
`coverage(reads)`  # how many reads cover any given nt in the genome  
  
### Main units of interests:  
Are the peak calls that highlight regions of the genome with a large number of reads. These peak calls are typically stored in BED files. Each peak is associated with a *score* that indicates the strength of the peak.  

- `library(rtracklayer)`  
- `peaks <- import.bed('file_name')`  # load peak BED files  
- `chrom(peaks)`   # Obtain peak coordinates  
- `ranges(peaks)`  # Obtain peak coordinates  
- `score(peaks)`  # Extracting peak scores   

## 1.2 Questions: ChIP seq recap:   
Let's quickly recap what you've just learned. Consider the statements below:
- ChIP-seq is used to measure gene expression. F  
- ChIP-seq is used to identify binding sites of proteins. T    
- Some proteins are involved in regulating gene expression. T  
- Cells in different organs can be distinguished by differences in their genome. F  

## 1.3 Analysis: Sequencing data  
The basic unit of a ChIP-seq dataset is a sequencing read. In this exercise, we'll look at how reads are represented in R, using reads from a small region on chromosome 20.  

Reads are stored in a `GAlignments` object. The `GAlignments` object is closely related to `GenomicRanges`  

Practice with functions  

- `print(reads)` # prints summary of the data  
- `start(reads)[1]` # to get start postiion of the first read  
- `end(reads)[length(reads)]` # to get the end position of the last read  
- `coverage(reads)` # compute number of raeds covering each position in the selected region  

##### Intermezzo - loading peaks in R?  
> How are peaks loaded into R? Into an GRanges object? How to import narrowPeak and broadPeak files into R in a valid GRanges format?  

**Options:**    

- ChIPpeakAnno package & `toGRanges()` function
- rtracklayer & `import()` function, but downside: doesn't work for narrowPeak/broadPeak files because these have slightly different columns compared to BED (ref: https://charlesjb.github.io/How_to_import_narrowPeak/  )  

  * **Solution**: use the `extraCols` parameter and give the name and type of every columns starting at the one that is different from the standard BED format.  
  * for narrowPeak:   
  
  `extraCols_narrowPeak <- c(singnalValue = "numeric", pValue = "numeric", qValue = "numeric", peak = "integer")`  
  `gr_narrowPeak <- import(narrowPeak_file, format = "BED", extraCols = extraCols_narrowPeak)`   
  
  * for broadPeak:  
  
  `extraCols_broadPeak <- c(singnalValue = "numeric", pValue = "numeric", qValue = "numeric", peak = "integer")`  
  `gr_broadPeak <- import(broadPeak_file, format = "BED",extraCols = extraCols_broadPeak)`  

> **IMPORTANT**: important peaks manually with the `read.table` function is much more complicated because we need to add the names of all the columns before converting in the GRanges format, but more importantly we need to make sure to convert the **0-based coordinate system of the BED file** to the **1-based coordinate system of the GRanges**!   

```{r getting peaks in r}
### using package ChIPpeakAnno
#path <- system.file("extdata", "Tead4.broadPeak", package="ChIPpeakAnno")
#peaks <- toGRanges(path, format="broadPeak")

### using rtracklayer 


```

## 1.4 Analysis: Peak calls   
*locations bound by the protein of interest will attract many overlapping reads, leading to peaks in coverage. These peaks are typically recorded with their genomic coordinates as well as a score that indicates the strength of the signal observed for this peak.*  

Peaks are stored in `GenomicRanges` object. In addition to the usual functions to access the content of GenomicRanges objects, two convenience functions are available for peak calls. You can use the `chrom` function to obtain the chromosome a peak is located on and the `score` function to obtain its score.  

Practice with functions:  

- `print(peaks)` # print summary of the 'peaks' object  
- `score(peaks)` # extract the score --> integer vector  
- `chrom(peaks)` # extract the chromosome where peaks are located --> factor-Rle object    
- `ranges(peaks)` # extract the start and stop locations --> IRanges object   

## 1.5 Video: ChIP-seq workflow  

Typical workflow:  

1. Read mapping; locate their position in the genome. Identifying the best map in a standardized version of the genome, the reference genome.  
2. Combine mapped reads into a coverage profile. Thus for each site in the genome the number or reads mapping is determined. Peaks are identified in this coverage profile. These correspond to the binding sites of a proteion or location of histone mark. It is possible to perform this in R but typical ChIP-seq pipelines use dedicated tools for this step.  
3. Importing mapped reads + peak calls into R  
4. Quality control  
5. Compare samples: identify interesting peaks. It has to be more than just a bindings sites. Eg peaks specific to a certain sample  
6. Interpretation, biological mechanisms using a variaty of data sources  

Useful visualizations:  

- Heatmaps to highlight broad similarities and differences between samples. It arranges samples and genomic regions by similarity. The grouping of genomic ranges can emphasize similarities between samples. Function to make these plots: `heatmap(read_counts)`  
- Bar + table plots to summarize the overlap between peak sets using `UpSetR` plots: `upset(fromList(peak_sets))`. Quick view of the similarity between sample sets.  

## 1.6 Analysis: Heatmap example  
Create a vector of colors to label groups (there are 2 samples per group)  
`group <- c(primary = rep("blue", 2), TURP = rep("red", 2))`  
Plot the sample correlation matrix `sample_cor` as a heat map  
Use the group colors to label the rows and columns of the heat map  
`heatmap(sample_cor, ColSideColors = group, RowSideColors = group, cexCol = 0.75, cexRow = 0.75, symm = TRUE)`

Create a heat map of peak read counts  
Use the group colors to label the columns of the heat map  
`heatmap(read_counts, ColSideColors = group, labRow = "", cexCol = 0.75)`  

## 1.7 Analysis: Genes make a difference  
Use genome annotations to make sense of ChIP-seq results. Analyze two sets of genes: (1) all genes associated with peaks and (2) only genes associated with peaks that show  differential binding   

Use `upset()` from `UpSetR` packages to visualize overlap.  

- `upset(from List(gene_lists))` # gene_lists object contains the geneIDs per sample. Bargraph output counts number of unique and overlapping genes. Dot plot below indicates whether these genes were unique or present in multiple gene lists    

[upsetr package ](http://gehlenborglab.org/research/projects/upsetr/)  
[r-bloggers upsetr](https://www.r-bloggers.com/2018/07/hacking-our-way-through-upsetr/)  


## 1.8 Video: ChIPseq results summary  
Sample heatmap: is there a difference between groups? Also usefull for assessing sample quality.  

Height peaks per sample: are peaks of same or different intensity between groups?  

upset plot: Overlap in genes associated with peak calls in different samples.  

## 1.9 Questions: Understanding ChIP-seq data  

# Ch2 Preparing ChIP-seq data  
## 2.1 video: Importing data  

The first steps of a ChIP-seq analysis, mapping and peak calling, are generally performed by specialized tools prior to importing data into r. There are a variaty of tools available. These data were mapped with bwa and peaks were identified with macs.  

Aligners output Sequence Alignment Map files, or SAM files. These are TAB-delimited text files and readable for us but are very large and are therefore stored in a compressed version which we call BAM files (for Binary Alginment Map). Dedicated tools are developed as well such that we can manipulate and read the BAM files without needing to convert them back to the large, SAM format.  

The BAM files contain information about the read sequence and how it was mapped to the reference genome. It thus tells you which part of the reference genome is most similar to this read, how the two differ, as well as several indicators that tell you how reliable the alignment between read and genome sequence is. The BAM file format allows the storage of optional tags that allow additional information to be stored with each alignment.   

We can work with these alignment files directly but it is much more convenient to work with dedicated tools for this file format. 

The SAM, VCF, GFF and Wiggle formats are using the 1-based coordinate system.  
The BAM, BCFv2, BED, and PSL formats are using the 0-based coordinate system.  

**Fields in a BAM file**:  

- The header lines tell you how the alignment was performed, incl. which reference genome was used and the program (or *aligner*) used to align reads to the reference  
- Following the header are records of read alignments, with 1 line per read. So if we count all the lines, we get the number of reads in the file. These records hold a lot of information:  
  
  * Read name similar to name in fastq file line 1   
  * Flag, encodes alignment information of the read in 12 "bits". It can, for example, tell you whether the corresponding read is mapped, unmapped or a PCR or optical duplicate. This encoding is not the easiest to immediatetely understand, luckily there are webtools to summarize for us what each flag number means: [from samformat](https://www.samformat.info/sam-format-flag), or [Broad Institute](https://broadinstitute.github.io/picard/explain-flags.html).  
  * Position of the alignment (start): Eg. `chr20 29803915`   
  * Mapping quality score, the program adds this score but different programs use different scores, can have value of `0` to `255`    
  * CIGAR string, gives a summary of the alignment per nt: `51M`, encodes information about among others the number of matching nt's, whether there is a deletion  
  * Reference sequence and position of paired read:  `chr20 29804200`   (if not used `0 0`)   
  * Read sequence, similar to line 2 in fastq file.   
  * Phred quality score of the read (ASCII encoded), similar to line 4 of the fastq file, eg: `CCCFFFHHJJJAA...`      

<a href = "https://gatk.broadinstitute.org/hc/en-us/articles/360035890791-SAM-or-BAM-or-CRAM-Mapped-sequence-data-formats">![Broad Institute, SAM or BAM or CRAM - Mapped sequence data formats](images/week1/2_seq2science/wk1_2_BAM_fields_broadinstitute.png) 
</a>  

CIGAR abbreviations:      
![images/week1/2_seq2science/wk1_2_BAM_file_CIGAR_string.png]   

FLAG abbreviations:  
![images/week1/2_seq2science/wk1_2_BAM_file_FLAG_encoding.png]   

<br>  
**R packages for BAM files**   

- `Rsamtoos` - package from Bioconductor provides functions for indexing,r eading, filtering and writing of BAM files.   
- Once BAM files are indexed they can be imported into r using `readGAlignments()` function from the `GenomicAlignments` packages, returns a `GAlignments` object with alignment info for each read.  
- Limit data import only to regions of interest using `bam_views <- BamViews(bam_file, bamRanges=ranges)` function from that same package. Followed by `reas_sub <- readGAlignments(bam_views)`  
- Regions of interest could be a chromosome, the peak calls from a BED file, or specified region eg `GRanges("chr20", IRanges(start=29805000, end=29820000))`   
- Import peak calls from BED file using `import.bed(peak.bed, genome = "...")` from the `rtracklayer` package.   

## 2.2 Exercise: Reading BAM files  
*To get started, ... *  
Load reads form chr20_bam file  
`reads <- readGAlignments(chr20_bam)`  
Create a `BamViews` object for the range 29805000 - 29820000 on chromosome 20  
`bam_views <- BamViews(chr20_bam, bamRanges=GRanges("chr20", IRanges(start=29805000, end=29820000)))`  
Load only the reads in that view  
`reads_sub <- readGAlignments(bam_views)`  
Inspect the `reads_sub` object using `str()`  
`str(reads_sub)`  

`reads_sub` is a list of `GAlignment` object, each with 4 slots.  

## 2.3 Exercise: Reading BED files
Load peak calls from chr20_peaks  
`peaks <- import.bed(chr20_peaks)`  
Create a BamViews object  
`bam_views <- BamViews(chr20_bam, bamRanges=peaks)`  
Load the reads  
`reads <- readGAlignments(bam_views)`  

## 2.4 Video: Closer look at peaks   
Using `Gviz` package  
Plot includes:  

- Ideogram - `IdeogramTrack(chromosome, reference genome)`    
- Coverage per nt, without displaying individual alignments, `GRanges` object, generated with `coverage()` argument --> make into track with `DataTrack()` function, eg `cover_track <- plotTracks(cover_ranges, window=10500, type="polygon", name="Coverage",fill.mountain=c("lighgrey", "lightgrey"), col.mountain="grey")`  
- Annotation tracks:  
  
  * peaks, eg `AnnotationTrack(peak_calls, name="Peaks")`  
  * genes, eg `GeneRegionTrack(TxDb.Hsapiens.UCSC.hg19.knownGene, chromosome="chr12",                       start=101360000, end=101380000, name="Genes")`  
  * chromosomal position with `GenomeAxisTrack()`     

Put together with the `plotTracks()` fuction:  
`plotTracks(list(ideogram, cover_track, peak_track, GenomeAxisTrack()), chromosome="chr20", from=start_pos, to=end_pos)`  

Genes from `TxDb.Hsapiens.UCSC.hg19.knownGene` package  

**We will use the UCSC GB for this**  

## 2.6 Video: Cleaning ChIP-seq data  
Common problems that may result in increase artefacts and noise, that is accumulation of reads in regions that don't actually contain binding sites of the protein of interest. Eg.:  
* Genomic repeats; these occur over and over again. The origin of reads coming from these reigons is difficult to pinpoint. Any extra copies in the sample will generate extra coverage in those repeats in the reference  
* Low complexity regions contain lot of sequence simalirty of sequences and the quality of sequence in the reference is low. Making it difficult to accurately pinpoint the true origin of a read in the reference  
* Amplification Bias during the library preperation. It is often needed to produces sufficient DNA for sequencing analysis. But some DNA molecules produce more copies than others, these will use more reads and this may result in a pile-up of reads in your analysis.  

Tools to produce, systematic, summarizations of quality metrics of all samples as tables and plots. In R `ChIPQC` package. This produces a HTML report from bam and bed file with comma seperated file with sample information to assign sample to bed and bam files. These groupings are used to generate summaries for groups of samples.  

How to deal with potential problems in the data?  

- remove additional reads with exactly the same mapping coordinates, 'remove duplicate reads', to gurad against amplification bias.  
- remove reads with multiple hits or have a low mapping quality (indication that alignment is incorrect) prior to peak calling as these are likely incorrectly assiged reads.  
- Some peakcallers allow the use of placklisted reagions that will not produce any peak calls for these. If this isn't the case, you should remove peaks in these regions from the peak calls prior to futher analyses. Blacklisted regions are available from the ENCDOE project.  

## 2.7 Exercise: Removing blacklisted regions  
`ChIPQC` package provides blacklist.  
Also available from ENCODE:   http://hgdownload.cse.ucsc.edu/goldenPath/hg19/encodeDCC/wgEncodeMapability/  

Find all overlaps between peaks and blacklisted regions  
`blacklisted <- findOverlaps(peaks, blacklist.hg19, type="within")`  

Create a plot to display read coverage together with peak calls and blacklisted regions in the selected region   
`cover_track <- DataTrack(cover, window=10500, type="polygon", name="Coverage", fill.mountain=c("lighgrey", "lightgrey"), col.mountain="grey")`  

Calculate peak_track and region_track, plot plotTracks   
`peak_track <- AnnotationTrack(peaks, name="Peaks", fill="orange")`  
`region_track <- AnnotationTrack(region, name="Blacklist")`  
`plotTracks(list(ideogram, cover_track, peak_track, region_track, GenomeAxisTrack()), chromosome="chr21", from=start(region)-1000, to=end(region)+1000)`   

Remove all blacklisted peaks   
`clean_peaks <- peaks[-from(blacklisted)]`   

## 2.8 Exercise: Filtering Reads  
Load reads with mapping qualities by requesting the "mapq" entries
`reads <- readGAlignments(bam_file, param=ScanBamParam(what="mapq"))`  

Identify good quality alignments
`high_mapq <- mcols(reads)$mapq >= 20`  

Examine mapping quality distribution for high and low quality alignments
`boxplot(mcols(reads)$mapq ~ high_mapq, xlab="good quality alignments", ylab="mapping quality")`  

Remove low quality alignments
`reads_good <- subset(reads, high_mapq)`  

## 2.10 Video: Assessing enrichment  
Reads are generated by sequencing the ends of DNA fragments. Signal becomes clearer when reads are extended to have the full length of the original fragment.  

See how it looks different in real data, using reads or (mean) fragment length.  

**Determine median fragment lengths per smaple**:  
`reads <- readGAlignments(bam)`  
`reads_gr <- granges(reads[[1]])`    
`frag_length <- fragmentlength(qc_report)["sampleid]` # function from chipqc package  

Extend reads with `resize()` function from `GenomicRanges` package: `reads_ext <- resize(reads_gr, width = frag_length)`   
`cover_ext <- coverage(reads_ext)`  

**How does coverage in peaks compare to coverage in other parts of the genome?**  
First partition the genome into short windows and then assign each peak to a peak, background or blacklisted region.  

1. make bins with `tileGenome(seqinfo(reads), tilewidth = 200, cut.last.tile.in.chrom =T)` from  `GenomicRanges` package  
2. find overlap between bins and peaks with `peak_bins_overlap <- finOverlaps(bins,peaks)` and extract bins located in peaks `peak_bins <- bins[from(peak_bins_overlap),]`. The `from()` function helps us obtain the index of each bin that overlaps with a peak.     
3. count reads overlapping each peak bin with `peak_bins$score <- countOverlap(peak_bins, reads)`  

Written as function:  
`count_bins <- function(reads, target, bins){overlap <- from(findOverlaps(bins, target)); target_bins <- bins[overlap, ]; target_bins$score <- countOverlaps(target_bins,reads); target_bins }`  

Call function for peaks, blacklisted regions and rest:  

- `peaks_bins <- count_bins(read_ext, peaks, bins)`  
- `bl_bins <- count_bins(read_ext, blacklist.hg19, bins)`
- `bkb_bins$score <- countOverlaps(subset(bins, -peak_bins, -bl_bins), reads_ext)`  

Plot coverage in each region.  Have to zoom in on peaks to see enchrichment. 

## 2.11 Exercise: Computing coverage  
Extend reads to the average fragment length of 183 bp
`reads_ext <- resize(reads_gr, width=183)`  
Compute coverage  
`cover <- coverage(reads_ext)`  

## 2.12 Exercise: Peaks vs. background  
Prepare read counts for plotting by organising them in data frames  
`peak_scores <- data.frame(source="peaks", fragments=peak_bins$score)`  
`bl_scores <- data.frame(source="blacklist", fragments=bl_bins$score)`  
`bkg_scores <- data.frame(source="background", fragments=bkg_bins$score)`   
`scores <- rbind(peak_scores, bl_scores, bkg_scores)`  

Create a boxplot of the read counts by bin type  
`ggplot(scores, aes(y=fragments, x=source)) + geom_boxplot()`  

Control samples can be used to fitler out the high signal in some background regions.  

# Ch3 Comparing ChIP-seq samples  
## 3.1 Video: Intro diff binding   
In this case, look at difference in response between primary and resistant cancers.  

Are samples from the same group generally similar? --> PCA and clustering help with this    

One way is to use PCA. Method to uncover some of the underlying structures in the dataset. It identifies the directions or PCs with most variation between data points.   

Depending how you look at the data, differences between groups become more or less obvious. Using the first two PCs we can define a 2d plane that pases through the cloud of data points, minimizing the distance between points as much as possible. Rotating the data such that we look directly at the plane, we get the PC plot.  

`ChIPQC` makes it very easy to get *PCA* using `plotPrincmp(counts)` function. Need a consistent set of peaks for alls amples, *consensus peak set* with corersponding read counts. Use function `dba.count(qc_results, summits = 250)` from `diff.bind` package to get this set. Summits detemines the width of the peaks.        

Another appraoch: *clustering samples* based on read counts for each peaks.   

- Many ways to do this. Here hierarchical clustering. Uses pairwises distances between samples to build a hierarchy or tree of samples, called a dendrogram.  
- Compute distances with `dist()` function, computes distance between rows of a matrix. If you want the distance between samples, transpose the matrix `dist(t(coverage))`.  
- Create dendrogram with `dendro <- hclust(distance)`  
- plot dendrogram with `plot(dendro)`  

Heatmap can highlight the differences between samples: Create heatmap with `dba.plotHeatmap(peaks, maxSites = peak_count, correlatoins = F)`, needs a `dba` object of peaks.    

'dba' object comes from the 'diffBind' package.  

## 3.2 Questions: Do the peaks look the same to you?   
- Exampine example PCA plot and agree or disagree with statments.  
## 3.3 Code: Clustering samples   

1. calculate distance between samples based on normalized coverage of peaks using `dist()`  
2. group similar samples with `hclust()`  
3. plot with `plot()`   

How many clusters do you think the samples fall in to?  

## 3.4 Code: Visualize differences in prot. binding   

Heatmap compares peak intensity across samples. Can help highlight patters in pretein binding that distinguish between groups of samples.   

## 3.5 Video: Testing for diff binding   

Which difference is enough petween the two gropus that we are confidence to say that they are not due to random fluctuations in the data.  

Use statistical analysis of read counts to dientify significant differences between groups. Two commonly used approaches for this: DESeq2 or edgeR. Default is DESeq2.  

Advantage of *DiffBind* is that it works hand in hand with ChIPQC and DESeq2.  

**Need consistent set of peaks.** 

Counting reads in peak set: `peak_counts <- dba.count(qc_output, summit = 250)`. Summit arguments indicates that peaks should be redefined around the consensus peak with width on either side. Here results in 500bp peaks.  

Need to tell DiffBind how to split/contrast the samples into groupings. Can be on attributes of datasets. Use function `dba.contrast(peak_counts, categories = DBA_CONDITION)`.  

DiffBind provides predefined groupings based on the attributes:  

- DBA_ID  
- DBA_TISSUE  
- DBA_FACTOR  
- DBA_TREATMENT  
- DBA_REPLICATE  
- DBA_CALLER  

Attributes are the columnnames of the sample description in the DBA object, shown when you `print(dba_object)`   

Differential binding analysis:  
`bind_diff <- dba.analyze(peak_counts)`  peak_counts is a `DBA` object.  

Look at the results with:  

- `dba.plotPCA(bind_diff, DBA_Condition, contrast = 1)`  
- `dba.plotHeatmap(bind_diff, DBA_Condition, contrast = 1)`  

## 3.6 Questions: Load read counts   
Evaluate `ar_counts <- dba.count(ar_peaks, summits=200)` command  
## 3.7 Code: Setting up the model   
Examine the ar_binding object  
`print(ar_binding)`  
Identify the category corresponding to the tumor type contrast  
`contrast <- DBA_CONDITION`  
Establish the contrast to compare the two tumor types  
`dba_peaks <- dba.contrast(ar_binding, categories=contrast, minMembers=2)`  
Examine the dba_peaks object to confirm that the contrast has been added  
`print(dba_peaks)`  

## 3.8 Code: Fitting the model   
Examine the `ar_binding` object to confirm that it contains the required contrast  
`print(ar_binding)`  
Run the differential binding analysis  
`ar_diff <- dba.analyze(ar_binding)`  
Examine the result  
`print(ar_diff)`  

## 3.9 Code: Revisiting PCA and Heat map   
Create a PCA plot using all peaks  
`dba.plotPCA(ar_diff, DBA_CONDITION)`  
Create a PCA plot using only differentially bound peaks
`dba.plotPCA(ar_diff, DBA_CONDITION, contrast = 1)`  
Create a heatmap using all peaks  
`dba.plotHeatmap(ar_diff, DBA_CONDITION, correlations = FALSE, maxSites = 440)`  
Create a heatmap using only differentially bound peaks  
`dba.plotHeatmap(ar_diff, DBA_CONDITION, contrast=1, correlations = FALSE)`  

`contrast` parameter directs dba.plotHeatmap to the contrast to use from the `dba.analyze()` calculation, stored in the ar_diff object. If not specified, all peaks will be used.  

## 3.10 Video: Closter look at diff binding   
Detailed look at differential binding results with some plots:  

Plots from DiffBind package:  

**MA plot** 
- visualizes relationship between average peak instensity and change in peak intensity between conditions. Use `dba.plotMA` function  
- log peak intensity on x-axis  
- log change intensity on y-axis  
- points of diff bounds peaks are highlighed in peaks.  
- highlight diff peaks 
- highlight also bigger trends in the data. Most dots should correspond to no difference between groups and most dots at horizontal line. If they are not, are systematic bias that should be addressed with appropriate data normalization.  

**Volcano plot**:  
- y-axis = negative log p-values or = -log10(FDR)  
- x-axis = log(FC) = log2(resistant) - log2(responsive)  
- function `dba.plotVolcano()`  
- peaks with signficant evidance for differential binding in pink. This shows significance with magnitud of the change  
- highlights extreme or unusual peaks.  

**Boxplot**  
- summarizes the distribution of peak intensity bewteen groups and facilitates the comparision beetween groups
- `dba.plotBox(dba_object)`  
- median peak instensity + first and third quartile. More extreme observations indicated in whiskers and additional points 
- good indication of the location and spread of peak intensity of the groups.  


## 3.11 Code: MA plot    
dba.plotMA(ar_diff)  

## 3.12 Code: Volcano plot   
dba.plotVolcano(ar_diff)  

## 3.13 Code: Summarizing diff binding  
Create a box plot of the peak intensities  
`compare_groups <- dba.plotBox(ar_diff, notch=FALSE)`  

Inspect the returned p-values  
`print(compare_groups)`  


# Ch4 From Peaks to Genes to Function   
## 4.1 Video: Interpreting ChIP-seq peaks   
## 4.2 Code: Consolidating peaks   
## 4.3 Code: Using annotations   
## 4.4 Code: Annotating peaks   
## 4.5 Code: Which peaks are different?   
## 4.6 Video: Interpreting Gene lists    
## 4.7 Code: Associating peaks with genes   
## 4.8 Code: Finding common themes   
## 4.9 Code: Understanding the impact on pathways   
## 4.10 Code A closer look at pathways   
## 4.11 Video: Advanced ChIP-seq analysis  