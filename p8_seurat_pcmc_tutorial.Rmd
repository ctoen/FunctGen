---
title: "seurat_pcmc_tutorial"
author: "Written by: Klaas, Simon, Siebren, Christa ... "
output: 
  html_document:
    css: custom.css
    toc: true
    toc_float: true
    collapsed: false
    number_sections: false
    toc_depth: 3
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message=FALSE,warning=FALSE, cache=TRUE)
```

<style type="text/css">
.title {
  display: none;
}

#getting-started img {
  margin-right: 10px;
}

</style>

<div class="row" style="padding-top:20px;">

# Seurat Guided Clustering Tutorial  

Purpose: for myself to find DE genes and TFs among them in this dataset  

Ref: [seurat tutorial](https://satijalab.org/seurat/v3.2/pbmc3k_tutorial.html)   

```{r install seurat, message=T, warning=F, eval = F}
library(dplyr)
library(Seurat)
library(patchwork) # to easily combine mutliple ggplots in one window, similar to but easier than gridExtra::grid.arrange() and cowplot::plot_grid, ref: https://github.com/thomasp85/patchwork  
```

Go through the processing steps to get the same clustering as in the tutorial:  
```{r laod data, eval = F}
# Load the PBMC dataset
pbmc.data <- Read10X(data.dir = "data/p8_pbmc3k_filtered_gene_bc_matrices/hg19/")
# Initialize the Seurat object with the raw (non-normalized data).
# outputs in pbmc[["RNA"]]@counts
pbmc <- CreateSeuratObject(counts = pbmc.data, project = "pbmc3k", min.cells = 3, min.features = 200)
 pbmc
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")
# continue with cells that likely represent a viable cell and are not duplicates by: 
pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
# global-scaling normalization: normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result
# outputs in pbmc[["RNA"]]@data
pbmc <- NormalizeData(pbmc, normalization.method = "LogNormalize", scale.factor = 10000)
# identify highly variable features, focusing on these genes helps to highlight biological signal in single-cell datasets. Plot to ensure that it is the same as tutorial.
pbmc <- FindVariableFeatures(pbmc, selection.method = "vst", nfeatures = 2000)
top10 <- head(VariableFeatures(pbmc), 10)
plot1 <- VariableFeaturePlot(pbmc)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot2
```

```{r scaling and pca, fig.height = 15, fig.width=9, eval = F}
# scale data such that mean expression across cell for given gene is 0 and variance is 1, gives equal weight to all genes so that highly expressed genes do not dominate, standard pre-processing step for dimensionality reduction techniques
# outputs in pbmc[["RNA"]]@scale.data
all.genes <- rownames(pbmc)
pbmc <- ScaleData(pbmc, features = all.genes)

# perform linear reduction using PCA, by default on only highly variable features and check result in dimheatmap
pbmc <- RunPCA(pbmc, features = VariableFeatures(object = pbmc))
DimHeatmap(pbmc, dims = 1:15, cells = 500, balanced = TRUE)

### skip part to find dimensionality of the data because I'm for now only interested in the clusters and DE genes
```

```{r clustering, eval = F}
# cluster the data
pbmc <- FindNeighbors(pbmc, dims = 1:10)
pbmc <- FindClusters(pbmc, resolution = 0.5)
# If you haven't installed UMAP, you can do so via reticulate::py_install(packages ='umap-learn')
# note that you can set `label = TRUE` or use the LabelClusters function to help label individual clusters
pbmc <- RunUMAP(pbmc, dims = 1:10)
DimPlot(pbmc, reduction = "umap")
# find markers for every cluster compared to all remaining cells, report only the positive ones
pbmc.markers <- FindAllMarkers(pbmc, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
pbmc.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC)

```

Fortunately in the case of this dataset, we can use canonical markers to easily match the unbiased clustering to known cell types:

cluster ID | markers | cell type  
0 | IL7R, CCR7 | naive CD4+ T cell  
1 | IL7R, S100A4 | Memory CD4+ T cell 
2 | CD14, LYZ | CD14+ Mono   
3 | MS4A1 | B  
4 | CD8A | CD8+ T cell   
5 | FCGR3A, MS4A7 | FCGR3A+ Mono  
6 | GNLY, NKG7 | NK  
7 | FCER1A, CST3 | DC  
8 | PPBP | Platelet  

```{r assign clusters, eval = F}
new.cluster.ids <- c("Naive CD4 T", "Memory CD4 T", "CD14+ Mono", "B", "CD8 T", "FCGR3A+ Mono", 
    "NK", "DC", "Platelet")
names(new.cluster.ids) <- levels(pbmc)
pbmc <- RenameIdents(pbmc, new.cluster.ids)
DimPlot(pbmc, reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend()
```

## now with pbmc10k dataset  
[link](	https://support.10xgenomics.com/single-cell-gene-expression/datasets/3.0.0/pbmc_10k_v3)  
[Downlaod Feature / cell matrix (filtered)](https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.tar.gz)  

Peripheral blood mononuclear cells (PBMCs) from a healthy donor (the same cells were used to generate pbmc_1k_v2, pbmc_10k_v3). PBMCs are primary cells with relatively small amounts of RNA (~1pg RNA/cell).  

- 11,769 cells detected.  
- Sequenced on Illumina NovaSeq with approximately 54,000 reads per cell.  
- 28bp read1 (16bp Chromium barcode and 12bp UMI), 91bp read2 (transcript), and 8bp I7 sample barcode  
- run with --expect-cells=10000.    

[dataset summary](https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_web_summary.html)   

```{r pbmc10k , eval = F}
pbmc10k.data <- Read10X(data.dir = "data/p8_pbmc10k10k_filtered_feature_bc_matrix")
pbmc10k <- CreateSeuratObject(counts = pbmc10k.data$`Gene Expression`, project = "pbmc10k3k", min.cells = 3, min.features = 200)
pbmc10k
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
pbmc10k[["percent.mt"]] <- PercentageFeatureSet(pbmc10k, pattern = "^MT-")
# continue with cells that likely represent a viable cell and are not duplicates by: 
pbmc10k <- subset(pbmc10k, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
# global-scaling normalization: normalizes the feature expression measurements for each cell by the total expression, multiplies this by a scale factor (10,000 by default), and log-transforms the result
# outputs in pbmc10k[["RNA"]]@data
pbmc10k <- NormalizeData(pbmc10k, normalization.method = "LogNormalize", scale.factor = 10000)
# identify highly variable features, focusing on these genes helps to highlight biological signal in single-cell datasets. Plot to ensure that it is the same as tutorial.
pbmc10k <- FindVariableFeatures(pbmc10k, selection.method = "vst", nfeatures = 2000)
top10 <- head(VariableFeatures(pbmc10k), 10)
plot1 <- VariableFeaturePlot(pbmc10k)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot2
all.genes <- rownames(pbmc10k)
pbmc10k <- ScaleData(pbmc10k, features = all.genes)

# perform linear reduction using PCA, by default on only highly variable features and check result in dimheatmap
pbmc10k <- RunPCA(pbmc10k, features = VariableFeatures(object = pbmc10k))
pbmc10k <- FindNeighbors(pbmc10k, dims = 1:10)
pbmc10k <- FindClusters(pbmc10k, resolution = 0.5)
# If you haven't installed UMAP, you can do so via reticulate::py_install(packages ='umap-learn')
# note that you can set `label = TRUE` or use the LabelClusters function to help label individual clusters
pbmc10k10k <- RunUMAP(pbmc10k10k, dims = 1:10)
DimPlot(pbmc10k10k, reduction = "umap")

#new.cluster.ids <- c("Naive CD4 T", "Memory CD4 T", "CD14+ Mono", "B", "CD8 T", "FCGR3A+ Mono", 
#    "NK", "DC", "Platelet")
#names(new.cluster.ids) <- levels(pbmc10k)
#pbmc10k <- RenameIdents(pbmc10k, new.cluster.ids)
#DimPlot(pbmc10k, reduction = "umap", label = TRUE, pt.size = 0.5) + NoLegend()
```

## TFs in PBMC3k dataset  



