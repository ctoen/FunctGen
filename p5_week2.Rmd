---
title: "2. Peaks in r"
output:
  html_document: 
    collapsed: no
    css: custom.css
    highlight: pygments
    theme: cerulean
    toc: yes
    toc_float: yes
editor_options:
  chunk_output_type: console
---

<style type="text/css">
.title {
  display: none;
}

</style>


```{r setup, include=FALSE}
knitr::opts_chunk$set(message=FALSE,warning=FALSE, cache=TRUE)
```

```{r setup-libraries, echo = F}
#installed required libraries via .yaml file environment_v3_withversions.yml
#see Home/GitHub/learnr_20201020_installing_learnr_conda_environment.txt
library(IRanges)
library(tidyverse)
library(GenomicRanges)
library(plyranges)
library(rtracklayer)
library(VennDiagram)
library(UpSetR)
library(GenomicFeatures)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene 
library(org.Hs.eg.db)
library(ChIPseeker)
library(ChIPpeakAnno)
library(genomation)
```

```{r fontcolorfunction, echo = F}
colorize <- function(x, color) {
  if (knitr::is_latex_output()) {
    sprintf("\\textcolor{%s}{%s}", color, x)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='color: %s;'>%s</span>", color, 
      x)
  } else x
}

# can be used as inline code, eg: `r colorize("Additional Ideas:", "red")`  
```

```{r plotranges function, echo = F}
# ref https://github.com/genomicsclass/ph525x/blob/master/R/plotRanges.R  
plotRanges <- function(x, xlim = x, main = deparse(substitute(x)),
                       col = "black", sep = 0.25, ...)
{
  height <- 0.5
  if (is(xlim, "Ranges"))
    xlim <- c(min(start(xlim)), max(end(xlim)))
  bins <- disjointBins(IRanges(start(x), end(x) + 1))
  plot.new()
  plot.window(xlim, c(0, max(bins)*(height + sep)))
  ybottom <- bins * (sep + height) - height
  rect(start(x)-0.5, ybottom, end(x)+0.5, ybottom + height, col = col, ...)
  title(main)
  axis(1)
}
```


## 2.1 Introduction   
<br>
In week 1 we discussed the major steps imvolved in obtaining genomics data, from experiment to raw data to normalized signal and peaks. We examined histone PTM ChIP-, DNaseI-, and RNA-seq data of monocytes in the UCSC genome browser and searched for regions with increased signal, *peaks*. We looked at the position of these peaks in the chromosome and with respect to genes as well as the co-occurence of different marks.   
<br>
These observations showed you that some marks are associated with particular functional elements, as was also discussed in class (eg active enhancer, active promoter, silenced domains).   
<br>
**This week we will put numbers to these observations and perform computational analyses to answer common questions including:** "*How many peaks do I have?*", "*Is this mark statistically enriched in a particular genomic element?*", "*Which and how often do marks co-occur?*","*The expression of which gene could be affected by this mark?*",  and "*What is the signal of the mark around a particular element of interest like the TSS?*"   
<br>

### 2.1.1 Learning Objectives  

> 1. Create `GRanges` object which store genomics interval data (eg. peaks)      
2. Perform basic calculations on these `GRanges` objects     
3. Obtain genes, promoters, introns or exons of your reference genome of interest from database objects (TxDb objects)   
3. Detect & count overlap between two or more GRanges objects   (`countOverlaps(query, subject)`, `findOverlaps(query, subject)`)    
4. Visualize this overlap (venndiagram `r colorize(", barplots or upsetr plots", col = "red")`)  
6. Visualize the distribution of chip-seq peaks over genomic elements `r colorize("piechart, barchart, UpSetR or, ggplot + geom_bar with index at the bottom for the different combinations", "red")`.     
7. Statistically test for enrichment of histone marks in (a) particular genomic region(s).   
8. Assign peaks to the closest TSS/genes   
9. Calculate and plot the distance between midpoints or summits of peaks and the TSS   
10. Plot the read density around the TSS in a line plot    
- These refer to Global learning objectives #4-5.   

Global learning objectives:  

4. Quantify and visually summarize the genomic distribution of histone ChIP-seq peaks and signal strength in r.   
5. Statistically test for enrichment of histone marks in functional genomic elements.  
<br>  

***  
<br> 

> TEASER... let's look at some of the plots you will make.    

<br>  

***  
<br> 

## 2.2 Intro Bioconductor & GenomicRanges        
### 2.2.1 Bioconductor  
[Bioconductor](https://www.bioconductor.org/) is a special repository of packages for the analysis of high throughput genomic data in r. Packages are often heavily dependend on each other and regular releases and a special installer ensure that you install package version that can work together. Usually you would use the `biocManager::install()` command to install these packages. But in this tutorial, all required packages are already installed.  
<br>
Bioconductor packages that we will be using include:   

package | purpose   
--|--    
[GenomicRanges](https://bioconductor.org/packages/release/bioc/vignettes/GenomicRanges/inst/doc/GenomicRangesIntroduction.html) | Provides the `GRanges` data structures to store and handle genomic intervals.  
[plyranges](https://bioconductor.org/packages/release/bioc/html/plyranges.html) | `dplyr`-like interface for interacting with `Ranges` data structures.    
[GenomicFeatures](https://www.bioconductor.org/packages/release/bioc/html/GenomicFeatures.html) | Functions to retrieve and manage genomic features from public databases.  
[GenomicAlignments](https://bioconductor.org/packages/release/bioc/html/GenomicAlignments.html) | Provides `GenomicAlignments` data structures to store short sequence alignments for read counting, computing the coverage, junction detection, and working with the nucleotide content of the alignments .    
[rtracklayer](https://www.bioconductor.org/packages/release/bioc/html/rtracklayer.html) | Provides functions to import and work with annotation files with various formats (GFF, BED, bedGraph, BED15, WIG, BigWig and 2bit).   
[ChIPpeakAnno](https://www.bioconductor.org/packages/release/bioc/html/ChIPpeakAnno.html) | Toolkit for analysis of ChIP-seq data.  
[genomation](https://www.bioconductor.org/packages/release/bioc/html/genomation.html) | Toolkit for annotation and visualization of genomics data.  
TxDb packages | Provide an R representation of gene models, each genome has a separate package.   
OrgDb packages | For a certain genome, contain mappings between a unique gene identifier and other kinds of identifiers (eg from Entrez gene identifyer to Gene Symbol)  
<br>
Bioconductor packages can use **data structures** different from `vectors`,`matrices` or `data.frames`. The `GRanges` data structure provided by the `GenomicRanges` package is an example and is used by many. We will come to those shortly.   
<br>
In addition, these "Bioconductor-specific-objects", like `GRanges`, generally have their own set of functions or methods that you can explore using `methods(class = "...")`. To find out the `class`, use `class(object_name)`.  
<br>
Here's a list of basic functions to explore objects and/or call the help on packages or functions:   

- Use `class()` to found out what kind of data structure you are dealing with  
- Use `show()` or `print()` to have r print a summary of your data    
- use `methods(class = "...")` to get a list of (default) methods or functions you can use to extract and manipulate the data, also *assessor* funcitons or *getter* and *setter* functions       
- use `help(package = "[packageName]")` to display the help page     
- use `vignette(package = "[packageName]")` to access a list of user guides, vignettes and other documentation. You can access this material via the `help(package = "[packageName]")`-page or immidiatly using `vignette(package = "[packageName]", "[vignetteName")`, eg. `vignette(package="GenomicRanges", "GenomicRangesIntroduction")`  
- Get help on a particular function: `?"[function,pachageName-method"]`, eg `?"flank,GenomicRanges-method"`   

<br>  

***  
<br> 

### 2.2.2 GenomicRanges: Constructing GRanges objects    
You are already familiar with the **data structures** `vector`, `matrix`, `data.frame` and `lists` in R. In genomics we often work with **interval** data. Think of peaks, genes, exons, ... any genomic region reported with a `chr`, `start`, and `end`.   
<br>
Storing these in a `data.frame` is possible but not very efficient. Eg. a simple manipulation such as shifting all reported intervals 2 bp to the right, requires you to manipulate 2 columns at the same time.  
<br>
Interval data can be much more efficiently handled with the `IRanges` package which works with a data structure especially developed for ranges of integers: `IRanges` objects.  
<br>
`IRanges` objects follow the tidy data principle: each row of a `IRanges` object corresponds to an interval, while each column will represent a variable about that interval, and generally each object will represent a single unit of observation (like gene annotations).   
<br>
To construct an `IRanges` we require at least two columns that represent the starting coordinate, finishing coordinate or the width of the interval. Here we create `IRranges` object `ir` with three intervals, starting at position `10`, `20` or `30`, all with a with of `5`:   
```{r IRanges example, echo = T}
ir <- IRanges(start=c(3,5,17), end=c(10,20,30))
print(ir)
```
<br>
Depicting it visually we see blocks representing the intervals along the horizontal axis:  
```{r IRanges plot, fig.width=5, fig.height=4, echo = F }
plotRanges(ir)
```
<br>
The `GenomicRanges` package extends this concept and requires a sequence name (eg a chromosome) for every interval. The core data structures of this package are `GRanges` objects and `GRangesList`, the latter being a list of `GRanges` objects.  
<br>
Here we reate a `GRanges` object using `ir` and call for it's `class` and summary (as this prints 6 lines by default, the whole object is printed in this case):    
<br>
```{r GRanges example, echo = T}
# create gr object: 
gr <- GRanges(seqnames = c("chr1", "chr1", "chr2"), ranges=ir)

# find out the class:  
class(gr)

# print a summary:
print(gr)
```
<br>
The `strand` column holds `*`, meaning the intervals are *unstranded*. We could have defined the `strand` by:  
<br>
```{r GRanges example2, echo = T}
# create gr object with strandinfo: 
gr2 <- GRanges(seqnames = c("chr1", "chr1", "chr2"), ranges=ir, strand = c("+", "-", "-"))
gr2
```
<br>

> **Exercise 1: Finish the following code, creating `my_gr` with:**     
>
- Invervals A-E located on resp. chr1, chr2, chr3, chr4 and chr5  (one interval per chromosome);  
- from A to E, start at position `3`, `5`, `13`, `18`, and `20`;  
- and a `width` of `5`, `7`, `6`, `9` and `11` bp;
- the A, B and C on the minus strand, D and E on the plus strand.  
Finish by printing the summary of `my_gr`.  


```{r q1_granges, exercise = TRUE, eval = F}
# create GRanges object 'my_gr' intervals A-C on resp. "chr1", "chr2", "chr3", "chr4" and "chr5": 
my_gr <- ....(seqnames = "...", 
              .... = IRanges(start = c(..), ... = c(5, 7, 9, 11)),
              strand = c("-", "-", ..))
# print my_gr summary
print(...)
```

```{r q1_granges-solution}
my_gr <- GRanges(seqnames = c("chr1", "chr2", "chr3", "chr4", "chr5"), 
              ranges = IRanges(start=c(3, 5, 13, 18, 20), width = c(5, 7, 9, 11)),
              strand = c("-", "-", "-","+", "+"))
# print my_gr summary
print(my_gr)
```
<br>
We can add scores and names to these intervals with `score(object_name) <-` and `names(object_name) <-`. Custom columns can be defined with the `$`-sign.
<br>

> **Exercise 2: Finish the following code**  
>  
> - adding to `my_gr` custom `names`,   
- random `score` and  
- GC% in the `GC`-column.  
- Finish by printing `my_gr`.     

```{r q2_adjust_mygr, exercise = T, eval = F}
set.seed(1234)
# add names to `my_gr`
..(my_gr) <- paste("peak", LETTERS[1:5], sep = "_")
# add a custom score
..(my_gr) <- round(runif(5, 0, 106), digits = 3)
# add custom GC content
..$.. <- round(runif(5, 0.35, 0.60), digits = 3)
# print the result
print(..)
```

```{r q2_adjust_mygr-solution, exercise = T, eval = T}
set.seed(1234)
# add names to `my_gr`
names(my_gr) <- paste("peak", LETTERS[1:5], sep = "_")
# add a custom score
score(my_gr) <- round(runif(5, 0, 106), digits = 3)
# add custom GC content
my_gr$GC <- round(runif(5, 0.35, 0.60), digits = 3)
# print the result
print(my_gr)
```
<br>
Notice that the names replace the rowIDs and that this object now holds 2 *metadata columns*, i.e. *data about the data*, besides the genomic coordinates.  

Genomic coordinates |  Metadata columns   
-- | --  
Printed on the left-hand side of the `|` | Printed on the right-hand side of the `|`   
Extract using `granges(object_name)` |  Extract as DataFrame with `mcols(object_name)` or `object_name$column_name` for a specific column   
Columns are restricted to `seqnames`, `ranges` and `strand` | Almost anything can be stored in the metadata, we defined `score` and `GC`-content here  

<br>
Information about the genome and sequences is stored in `seqinfo`. This tells us that the intervals are from sequences `chr1` to `chr5` but no additional information is reported about their lengths or the genome they originate from. Genome information can be appended using `seqinfo(my_gr) <- Seqinfo(genome="hg38")`. This automatically loads the sequence information specified by `genome` by querying the UCSC database.   
<br>
```{r report seqinfo, echo = T}
seqinfo(my_gr) <- Seqinfo(genome="hg38")
print(my_gr)
```
<br>  
Visually summarizing a `GRanges` object of exons from the:  

![](images/wk2_2_GRanges_fields_my_gr.png)

***  
<br> 

### 2.2.2 GenomicRanges: Basic manipulations with GRanges objects   
Accessor functions extract components of the `GRanges` object.  

- The `start()`, `end()`, `width()`, `ranges()` and `strand()` accessors extract the respective components of the genomic coordinates.   
- The `score()` prints the scores stored in metadata.
- `names()` prints the rownames.  

Other usefull functions to summarize, view or modify the intervals include:  

- `length()` prints the number of stored intervals.
- `head(object_name, n = ...)` and `tail(object_name, n = ...)` print `n` number of intervals in the head or tail of the object. Can be usefull for checking that the dataset is complete and calculations.    
- GRanges behave like vectors of ranges and can be subsetted using `[subset range, metadata columns]`.  
- `shift(object_name, shift = ...)` will move the intervals by a specific number of base pairs.  
- `flank()` will report a GRanges object with regions flanking the set of intervals, if the regions are stranded, by default the *upstream* region is reported.  

These are some basic functions, more can be found in the `GenomicRanges` vignettes.  
<br>
The `plyranges` packages has functions that are related to those in `dplyr` but work on `Ranges`:  

- Use the pipe operator `%>%` to combine functions in a workflow.  
- Group ranges with `group_by()`: eg `my_gr %>% group_by(strand)`.  
- Restrict rows using `filter()`: eg `my_gr %>% filter(GC < 0.4)` or `my_gr %>% group_by(strand) %>%  filter(GC == max(GC))`. After grouping this filter will be applied to each group seperately.  
- Summarise in `DataFrame` with `summarise()`: eg `my_gr %>% summarise(gc = mean(GC)`  

<br>

> **Exercise 3: Print the width, ranges and strand of `my_gr`**   

```{r q3_accessors, exercise = T, eval = F}
# report the width of intervals in my_gr
...(my_gr)

# report the ranges of intervals in my_gr
...(my_gr)

# report the strand
...(my_gr)
```

```{r q3_accessors-solution, exercise = T}
# report the width of intervals in my_gr
width(my_gr)

# report the ranges of intervals in my_gr
ranges(my_gr)

# report the strand
strand(my_gr)
```
> *Background*: strand is reported as an Rle object, shortly put, the `Lengths` report *how often* the corresponding input of `Values` is repeated in the sequence. In this example the '-' is repeated three times and followed by a '+' two times.   

> **Exercise 4:**
>
> 1. print head two lines of 'my_gr'. 
> 2. subset `my_gr` for interval 2, 3 and 4, print only the "GC" column of the metadata.      

```{r q4_headtail, exercise = TRUE, eval = F}
# print head 2 intervals
head(.., n = ..)
# subset interval 2, 3 and , include GC column
my_gr[.., ".."]
```

```{r q4_headtail-solution, exercise = TRUE}
# print head 2 intervals
head(my_gr, n = 2)
# subset interval 2, 3 and , include GC column
my_gr[2:4, "GC"]
```
<br>  

> **Exercise 5:**  
>
> - Report an interval 10bp upstream with repsect to the reported strand.  
> - Print this new object.   

```{r q5_flank, exercise = T, eval = F}
# report interval 10 bp `upstream` with respect to the reported strand
my_gr2 <- ...(my_gr, width = ...)
# print the object
..(..)
```

```{r q5_flank-solution, exercise = T}
# report interval 10 bp `upstream` with respect to the reported strand
my_gr2 <- flank(my_gr, width = 10)
# print the object
print(my_gr2)
```

<br>
**So far we discussed the basics of `GenomicRanges`. Let's look at real examples now.**  

<br>  

***  
<br> 

## 2.3 Importing peak files in R   
### 2.3.1 Data import  
Most genomic interval data comes in a tabular format that has the basic information about the location of the interval and some other information. Common file formats include BED, GFF or BigWig files. These can be imported with the base `object_name <- read.table("location/of/file.bed")` function and converted to a `GRanges` object using `gr_object <- as(object_name, "GRanges")`.  
<br>
A more quicker method is to use the `import()` function from the `rtracklayer` package. This function parses the files directly into `GRanges` objects with genomic ranges and metadata. The`readGAlignments()` function from the `GenomicAlignments` package parses BAM files with read alignments into `GAlignments` objects, which behave much like `GRanges` and are easy to convert to `GRanges`.   
<br>
You will import peak.bed files of the histone ChIP-seq experiment in monocytes we looked at in week 1. On the [BLUEPRINT methods page](http://dcc.blueprint-epigenome.eu/#/md/chip_seq_grch38) we can read that peak calling was performed with MACS2 software. We also note that for 4 ChIPs, the `-broad` option was included resulting in so-called `broadPeak` files. The others follow the `narrowPeak` file format.   

narrowPeak file | broadPeak file  
-- | --  
H3K27ac | H3K27me3   
H3K4me3 | H3K36me3  
H3K9/14ac | H3K9me3  
H2A.Zac | H3K4me1  

These two files are much alike (see [MACS2 github](https://github.com/macs3-project/MACS)) :  

column | information | narrowPeak description | broadPeak description   
-- | -- | -- | --  
1. | chromosome name | same | same    
2. | peak start | same | same       
3. | peak end | same | same      
4. | peak name | same | same   
5. | score | -10log(qvalue) \*\ 10, rounded down to integer value) | mean of -10log(qvalue) \*\ 10 across all positions  
6. | strand | +, - or \*\ for unstranded | same  
7. | fold_enrichment | at peak summit |  mean across all positions  
8. | -log10(qvalue) (*e.g.if qvalue = 1e-10, this value is 10*) | at peak summit  | mean across all positions  
9. | -log10(pvalue) | at peak summit | mean across all positions   
10. | relative summit | position relative to peak start | not reported   

We have restricted all peak files to chromosome 19 to limit the file size.  

> **Exercise 6:**
>
- Read in the following peak files wih the `import()` function from the `rtracklayer` package.  
- Define the appropriate file format, i.e. "narrowPeak" or "broadPeak".   

```{r q6_import_peakbed, exercise = TRUE, eval = F}
# H3k4me1 
mono_h3k4me1 <- rtracklayer::import("data/blueprint/bed/C000S5H2.ERX547981.H3K4me1.bwa.GRCh38.broad.20150527.chr19.bed", format = "...")

# H3K4me3  
mono_h3k4me3 <- rtracklayer::...("data/blueprint/bed/C000S5H2.ERX547984.H3K4me3.bwa.GRCh38.20150527.chr19.bed", format = "...")

# H3K9me3 
mono_h3k9me3 <- rtracklayer::...("data/blueprint/bed/C000S5H2.ERX547982.H3K9me3.bwa.GRCh38.broad.20150527.chr19.bed", format = "...")

# H3K27ac 
mono_h3k27ac <- rtracklayer::...("data/blueprint/bed/C000S5H2.ERX547980.H3K27ac.bwa.GRCh38.20150527.chr19.bed", format = "...")

# H3K27me3   
mono_h3k27me3 <- rtracklayer::...("data/blueprint/bed/C000S5H2.ERX547983.H3K27me3.bwa.GRCh38.broad.20150527.chr19.bed", format = "...")

# H3K36me3
mono_h3k36me3 <- rtracklayer::...("data/blueprint/bed/C000S5H2.ERX547979.H3K36me3.bwa.GRCh38.broad.20150527.chr19.bed", format = "...")
```

```{r q6_import_peakbed-solution, exercise = TRUE}
# H3k4me1 
mono_h3k4me1 <- rtracklayer::import("data/blueprint/bed/C000S5H2.ERX547981.H3K4me1.bwa.GRCh38.broad.20150527.chr19.bed", format = "broadPeak")

# H3K4me3  
mono_h3k4me3 <- rtracklayer::import("data/blueprint/bed/C000S5H2.ERX547984.H3K4me3.bwa.GRCh38.20150527.chr19.bed", format = "narrowPeak")

# H3K9me3 
mono_h3k9me3 <- rtracklayer::import("data/blueprint/bed/C000S5H2.ERX547982.H3K9me3.bwa.GRCh38.broad.20150527.chr19.bed", format = "broadPeak")

# H3K27ac 
mono_h3k27ac <- rtracklayer::import("data/blueprint/bed/C000S5H2.ERX547980.H3K27ac.bwa.GRCh38.20150527.chr19.bed", format = "narrowPeak")

# H3K27me3   
mono_h3k27me3 <- rtracklayer::import("data/blueprint/bed/C000S5H2.ERX547983.H3K27me3.bwa.GRCh38.broad.20150527.chr19.bed", format = "broadPeak")

# H3K36me3
mono_h3k36me3 <- rtracklayer::import("data/blueprint/bed/C000S5H2.ERX547979.H3K36me3.bwa.GRCh38.broad.20150527.chr19.bed", format = "broadPeak")
```
<br> 

***
<br>

### 2.3.2 Basic calculations   
Awesome! Let's take a quick look at one of these files, `mono_h3k4me3`  

> **Exercise 7:**  
>
> * What class is "mono_h3k4me3"?  
> * How many peaks are stored in "mono_h3k4me3"? TIP, use `length()` 
> * Use `print` to print a summary of "mono_h3k4me3".  
> * What is the distribution of peak sizes and scores? TIP, use `width()`  

```{r q7_peakfiles, exercise = T, eval = F}
# Find out the object class of "mono_H3K4me3"
...(mono_h3k4me3)

# How many peaks do we have?  
...(mono_h3k4me3)

# Print a summary of our peaks object
...(...)

# What is the distribution of peak sizes?   
summary(...(...))

# What is the distribution of peak scores?
summary(...(...))
```

```{r q7_peakfiles-solution, exercise = T}
# Find out the object class of "mono_H3K4me3"
class(mono_h3k4me3)

# How many peaks do we have?  
length(mono_h3k4me3)

# Print a summary of our peaks object
print(mono_h3k4me3)

# What is the distribution of peak sizes?   
summary(width(mono_h3k4me3))

# What is the distribution of peak scores?
summary(score(mono_h3k4me3))
```
<br>
The original .BED files lacked column headers. You can see that the `rtracklayer::import()` function automatically recognizes these columns because we gave it the file format. It adds the header name and ensures that data is reported in the right data type (eg numeric, integer, character etc.).  
<br>
We can also plot these data using base plots. Plotting with the `ggplots` packages is also possible, as long as we convert them to `data.frame` objects.  

> **Exercise 8:**  
> Plot the h3k4me3 peaksizes as a histogram and as a boxplot using the base `hist()` and `boxplot()` functions.   

```{r q8_h3k4me3_peaksizes, exercise = T, eval = F}
# plot the distribution of peak sizes for h3k4me3 as histogram
..(..(mono_h3k4me3), main = "Monocytes H3K4me3 ChIP-seq, chr19", xlab = "peak size", col = "gray")

# plot the same data as boxplot, ensue that "peak size" labels the right axis (x or y)
..(..., main = "Monocytes H3K4me3 ChIP-seq, chr19", ... = "peak size", col = "gray")
```

```{r q8_h3k4me3_peaksizes-solution, exercise = T}
# plot the distribution of peak sizes for h3k4me3 as histogram 
hist(width(mono_h3k4me3), main = "Monocytes H3K4me3 ChIP-seq, chr19", xlab = "peak size", col = "gray")

# plot the same data as boxplot, ensue that "peak size" labels the right axis (x or y)
boxplot(width(mono_h3k4me3), main = "Monocytes H3K4me3 ChIP-seq, chr19", ylab = "peak size", col = "gray")
```
<br>

> **Exercise 9: explore MACS2 output with ggplots**  
> 
> 1. Plot the distribution of h3k4me3 *scores* with ggplots `geom_histogram`
> 2. Plot the relationship between `scores` and `qValue` and between `scores` and `signalValue`   

```{r q9_hrk4m3_score_ggplot, exercise = T, eval = F}
# use as.data.frame() and mcols() to store metadata of mono_h3k4me3 in a new object
meta_h3k4me3 <- ..(..(mono_h3k4me3))

# plot distribution of scores as histogram with `geom_histogram()`
ggplot(data = ..) +
  ..(mapping = aes(x = ..), binwidth = 100)

# plot scores as boxplot 
ggplot(data = ..) +
  ..(mapping = aes(y = ..))

# plots qValue vs score with geom_point()
ggplot(data = ..) + 
  ..(mapping = aes(x = .., y = ..)) +
  labs(title = "Relationship between qvalue and score",
       subtitle = "Observe that 'scrore = -10log(qvalue) * 10, rounded down to integer value'")
```

```{r q9_hrk4m3_score_ggplot-solution, exercise = T}
# use as.data.frame() and mcols() to store metadata of mono_h3k4me3 in a new object
meta_h3k4me3 <- as.data.frame(mcols(mono_h3k4me3))

# plot distribution of scores as histogram with `geom_histogram()`
ggplot(data = meta_h3k4me3) +
  geom_histogram(mapping = aes(x = score), binwidth = 100)

# plot scores as boxplot 
ggplot(data = meta_h3k4me3) +
  geom_boxplot(mapping = aes(y = score))

# plots qValue vs score with geom_point()
ggplot(data = meta_h3k4me3) + geom_point(mapping = aes(x = qValue, y = score)) +
  labs(title = "Relationship between qvalue and score",
       subtitle = "Observe that 'scrore = -10log(qvalue) * 10, rounded down to integer value'")
```

<br>
Several peaks have a size >10000. You can found out which peaks these are with standard subsetting: `mono_h3k4me3[width(mono_h3k4me3)> 10000,]` or using `filter()` from `plyranges`.    
<br>
> **Exercise 10:**
Filter for peaks with width > 10kb using `filter()` from `plyranges`   

```{r q10_filter, exercise = T, eval = F}
# filter mono_h3k4me3 for peaks with size above 10kb
mono_h3k4me3 %>% ..(.. > ..)
```

```{r q10_filter-solution, exercise = T, echo = T}
# filter mono_h3k4me3 for peaks with size above 10kb
mono_h3k4me3 %>% filter(width > 10000)
```
<br>
Two h3k4me3 peaks have a size > 12kb. 

> **Exercise 11:**  
Go to the UCSC Genome browser, the expression of which gene(s) is/are likely controlled by the h3k4me3 peaks with a size > 12kb?  

> hints:  
1: subset the h3k4me3 peaks with `mono_h3k4me3[width(mono_h3k4me3)> 12000,]`  
2: peaks located at `chr19:4057708-4069982` and `chr19:35896740-35909444`  

```{r q11_ucsc, exercise = T, eval = F}
question("Which gene(s) could be controlled by  >12kb h3k4me3 peaks"?,
         answer("ZBTB7A"),
         answer("HCST"),
         answer("NKBID"),
         answer("TYROBP"),
         answer("all of the above", correct = T, message= "The peak at chr19:4057708-4069982 is part of the ZBTB7A promoter and likely involved in the expressino of that gene. The peak at chr19:35896740-35909444 spans all the other three genes and with these data it is impossible to determine whether it regulates only all, two or only one of them.")
)
```
<br>

> **Exercise 12:**  
> Now look at the peak scores. The promoters of which gene(s) is/are covered by the peak with the highest score?**  

> hints:  
>  
1: use `filter()`  
2: condition on `score == max(score)`  

```{r q12_maxscore, exercise = T, eval = F}
# find the peak peak with highest score
mono_h3k4me3 %>% ..(.. == ..(..))

```

```{r q12_maxscore-solution, exercise = T}
# find the peak peak with highest score
mono_h3k4me3 %>% filter(score == max(score))
```

```{r q13_ucsc, exercize = T, eval = F}
question("The promoters of which gene(s) are covered by the h3k4me3 peak with the highest score"?,
         answer("*AKAP8*", correct = T, message = "While this peak spans parts of both genes, it covers the promoter of *AKAP8* but the 3'UTR of *AKAP8L*." ),
         answer("*AKAP8L*", message = "Incorrect. Be aware of the directionaility of this gene by looking at the arrowsheads in the introns."),
         answer("Both", message = "Only one of the genes listed here. Look at the direction of transcription indicated by the arrowheads in the introns of the genes.")
)
```
<br>
Later on in this tutorial we will learn how to annotate peaks with the gene that they most likely control.  
<br>

***
<br>

### 2.3.3 GRangesLists  
These 6 `GRanges` objects can be transformed to one `GRangesList` using the function `GRangesList()`. These `list` objects will come in handy later on. Here, we will explore them a bit.   
<br>

> **Exercise 14: generate `mono_list`, a list of our `GRanges` objects.  

```{r q14_grangeslist, exercise = T, eval = F}
# make a list of your GRanges objects
mono_list  <- ...(mono_h3k4me1, mono_h3k4me3, mono_h3k9me3, mono_h3k27ac, mono_h3k27me3, mono_h3k36me3)
# add names to each element in the list
names(...) <- c("h3k4me1", "h3k4me3", "h3k9me3", "h3k27ac", "h3k27me3", "h3k36me3")
# print the length of your list  
...(mono_list)
```

```{r q14_grangeslist-solution, exercise = T}
# make a list of your GRanges objects
mono_list  <- GRangesList(mono_h3k4me1, mono_h3k4me3, mono_h3k9me3, mono_h3k27ac, mono_h3k27me3, mono_h3k36me3)
# add names to each element in the list
names(mono_list) <- c("h3k4me1", "h3k4me3", "h3k9me3", "h3k27ac", "h3k27me3", "h3k36me3")
# print the length of your list  
length(mono_list)
```
<br>
The `length` function now applies to the list and not to the individual items any more. To calculate the length of individual items, we can use (at least) two approaches:  

- We can access elements in the list using `[[]]`. Use the *index*: eg. `mono_list[[1]]` will extract the first item in the list. Or the name: eg `mono_list[["h3k4me3"]]` plot the peak widths of the h3k4me3 ChIP.   
- With the fuction `lapply(list_object, function)` we can apply a function to each element in the list. `lapply()` retunrs the results as a list. An additional advantage is that lapply accepts user-defined functions.   

<br>
```{r length of list item, echo = T}
# print the length of h3k4me3 chip object
length(mono_list[["h3k4me3"]])
# or print the length of each element at once with apply
lapply(mono_list, length) 
# lapply also accepts custom functions 
lapply(mono_list, function(x) summary(width(x)))
```
<br>
`unlist()` flattens the list to one object. Depending on the elements in the list this will return a `vector`, `matrix` or, if all elements have the same data structure and column names, one large version of that particular data structure.  
<br> 
E.g. `unlist(mono_list)` will give you one large `GRanges` object that is not very usefull because peaks of all marks are mixed up. `unlist(lapply(mono_list, length))`, on the other hand, returns a usefull vector of peak numbers per ChIP.  
<br>

> **Exercise 15: Make a barplot of peak numbers per ChIP**    
> 
> * Use the `mono_list` object
  * Obtain peak_counts with `lapply()`, and `unlist()`  
  * What function will you use within `lapply()`?

```{r q15_barplot, exercise = T, eval = F}
# unlist the lapply of length outputs a vector of lengths:  
(peak_counts <- ...(lapply(mono_list, ...)))
# barplot of the number of peaks, store this in 'bp':  
bp <- barplot(..., ylab = "Number of peaks", main = "Monocytes ChIP-seq; chr19")
# add actual values as text lables to the plot
text(bp, peak_counts, labels=names(peak_counts), pos=1)
```

```{r q15_barplot-solution, exercise = T}
# unlist the lapply of length outputs a vector of lengths:  
(peak_counts <- unlist(lapply(mono_list, length)))
# barplot of the number of peaks, store this in 'bp':   
bp <-barplot(peak_counts, ylab = "Number of peaks", main = "Monocytes ChIP-seq; chr19")
# add actual values as text lables to the plot
text(bp, peak_counts, labels = peak_counts, pos=1)
```
<br>
**Now that we have gotten to know the `GRanges` and `GRangesList` objects, and we have imported our monocyte ChIP-seq data in r, we would like to start counting the overlap among marks and with functional genomic elements like promoters, exons, introns, enhancers etc. But for the latter we also need genome annotations. We will get these from the genome centric `TxDb.Hsapiens.UCSC.hg38.knownGene` package.**  

<br>

***
<br>

## 2.4 Annotations and Genomic features  
### 2.4.1 TxDb database objects      
The `TxDb` class is a container for storing transcript annotations. It maps the 5’ and 3’ untranslated regions (UTRs), protein coding sequences (CDSs) and exons for a set of mRNA transcripts to their associated genome. `TxDb` objects have numerous accessors functions to allow such features to be retrieved individually or grouped together in a way that reflects the underlying biology. For example exons grouped by transcript or transcripts grouped by gene.  
<br> 
There are `TxDb` objects for many genomes. The ChIP-seq data were mapped to hg38 and we therefore loaded the `TxDb.Hsapiens.UCSC.hg38.knownGene` library for you and assigned it the shorter name `txdb`.  
<br> 
As we only have data on chromosome 19, a useful way to limit the size and length of returned elements (think of the number of not-overlapping promoters), is to inactivate all the other chromosomes.  
<br>  
The method `seqlevels(txdb_object)`, gives us the chromosomes that are currently active. Here we used the function as a **getter** funciton, a.k.a. to retrieve data. Instead, we can also use it as a **setter** function, e.g. `seqlevels(txdb_object) <- chr1` to set chromosome 1 active and the others inactive.   
<br> 

> **Exercise 16:**  
View the head 20 chromosomes used in `txdb` and limit the active chromosome to chr19.    

```{r q16_txdb, exercise =  T, eval = F}
# head of the list of chromosomes
head(...(txdb), n = ..)

# limit the active chromosomes to "chr19"
...(txdb) <- "..."

# check that "chr19" is indeed the only active chromosome
...(...)
```

```{r q16_txdb-solution, exercise = T}
# head of the list of chromosomes
head(seqlevels(txdb), n = 20)

# limit the active chromosomes to "chr19"
seqlevels(txdb) <- "chr19"

# check that "chr19" is indeed the only active chromosome
seqlevels(txdb)
```
<br>
From this point on in your R session, only chromosome 19 will be consulted when you call for ef genes. If you need to set it back, use `seqlevels(txdb) <- seqlevels0(txdb)`. Note the `0` in the argument on the right of the `<-`.  
<br>

### 2.4.2 Returning *GRanges* objects  
We can use these `TxDb` objects to get the genomic coordinates of genes, transcripts, coding sequences, exons, and promoters. It returns the coordinates as `GRanges` object using the functions:    

- `genes(txdb_object, columns = ..., filter = ...)`  
- `transcript(txdb_object, columns = ..., filter = ...)`  
- `cds(txdb_object, columns = ..., filter = ...)`
- `exons(txdb_object, columns = ..., filter = ...)`

- The `columns` argument selects columns to be included in the output. Candidate columns can be obtained with `columns(txdb_object)`.   
- The `filter` arguments restricts the output. Provide a list of filters. Valid names to filter on are "gene_id", "tx_id", "tx_name", "tx_chrom", "tx_strand", "exon_id", "exon_name", "exon_chrom", "exon_strand", "cds_id", "cds_name", "cds_chrom", "cds_strand" and "exon_rank". E.g. filter for all elements on the '+' strand of 'chr19': `filter = list(tx_chrom = "chr19", tx_strand = "+")`   

<br>
The `promoters(txdb_object,upstream =..., downstream =... )` function computes a GRanges object that spans the promoter region around the transcription start site for the transcripts in a TxDb object. The `upstream` and `downstream` arguments define the number of bases upstream and downstream from the transcription start site that make up the promoter region.  
<br>
Three- and five untranslated regions are obtained with resp `threeUTRsByTranscript` and `fiveUTRsByTranscript` and return `GRangesList` with the a `GRanges` element per transcript.  
<br>

> **Exercise 17:**
> 
> 1. Retrieve the transcripts located on chr19 (*TIP: look at the other exercises to determine which 'columns' you want to include.*)  
> 2. The transcript from which *gene* spans the widest region? (*TIP: we are looking for the GENEID)    
> 3. How many alternative transcripts has the gene in total?  
> 4. Retrieve the promoter regions defined as 2000 bp upstream and 400 bp downstream the TSS.  

```{r q17_txdb, exercise = T, eval = F}
# what is the name of the column with gene ids?
columns(txdb)

# retrieve transcripts located on chromosome 19, include gene id information in metadata
tx_chr19 <- ..(txdb, columns = "..")

# what is the maximum width?  
max_width <-  ..(..(tx_chr19))  

# filter tx_chr19 using this value (keep the () signs, this prints the output and assigns it to the object 'longest_tx')  
(longest_tx <- tx_chr19[..(tx_chr19) == ..,])   

# filter within genes() using this geneid, include the TXID column in the output 
long_gene <- ..(txdb, columns = "..", filter = list(.. = ".."))

# count the length of TXID in metadata to get the number of transcripts reported for this gene (TXID is a list with length 1)
length(long_gene$..[[1]])
```

```{r q17_txdb-solution, exercise = T, eval = T}
# find candidate columns that you can include  
columns(txdb)

# retrieve transcripts located on chromosome 19
tx_chr19 <- transcripts(txdb, columns = "GENEID")

# what is the maximum width?  
max_width <-  max(width(tx_chr19))  

# filter tx_chr19 using this value (keep the () signs, this prints the output and assigns it to the object 'longest_tx')  
(longest_tx <- tx_chr19[width(tx_chr19) == max_width,])   

# filter within genes() using this geneid, include the TXID column in the output 
(long_gene <- genes(txdb, columns = "TXID", filter = list(GENEID = "773")))

# count the length of TXID in metadata to get the number of transcripts reported for this gene (TXID is a list with length 1)
length(long_gene$TXID[[1]])
```
<br>
 
### 2.4.3 Select on TxDb objects    
You can also select elements from `TxDb` objects using `select` which returns a `data.frame` object.  

`AnnotationDbi::select(object_name, keys = c(""), columns = c(""), keytype = "")`   

- `keys = c("")`  

  * Requires a character vector used to query the database.  
  * Use `keytypes(txdb_object)` to explore which fields we could use as keys. You would expect that all columns can be used but some kinds of values make poor keys and so the `keytypes` list is often shorter than the `columns` list.    

- `columns = c("")`  

  * Character vector, which kind of data to return.  
  * Use `columns(txdb_object)` to explore the options.   
  * Curious about what the different fields hold? Use `help("COLUMN_NAME")`.   
  
- `keytype = ""`  

  * Defines the type of `keys` we are passing in.  
  * Eg. use "SYMBOL" when your keys are a list of official Gene Symbols  
  
> **Exercise 18:**  
For the transcripts belonging to `long_gene`, report the chromosome and strand information that will go with each of the transcript names.

```{r q15_txdb_select, echo = T, eval = F}
# obtain the transcriptIDs as character vector
my_keys <- as.character(unlist(long_gene$TXID))

# print the possible columns 
..(txdb)

# use index selection to make a character vector of the columns for transcript chromosome, start, end, strand, id and name
clmns <- columns(txdb)[c(..:..)]

# make the selection
my_selection <-  AnnotationDbi::select(txdb,
                     keys = ..,
                     columns = .., 
                     keytype = "..") 

# view head of the output
head(..)
```

```{r q18_txdb_select-solution, echo = T, eval = F}
# obtain the transcriptIDs as character vector
my_keys <- as.character(unlist(long_gene$TXID))

# print the possible columns 
columns(txdb)

# use index selection to make a character vector of the columns for transcript chromosome, start, end, strand, id and name
clmns <- columns(txdb)[c(16:21)]

# make the selection
my_selection <-  AnnotationDbi::select(txdb,
                     keys = my_keys,
                     columns = clmns,
                     keytype = "TXID") 

# view head of the output
head(my_selection)
```
<br>
**The gene ids have not been very informative so far. Gene Symbols are more informative. In the next section we will look at how we can obtain those. **

### 2.4.4 Gene names
The Entrez Gene identifiers reported in the TxDb object may not be informative to you. Vice versa, you may only have the Gene Symbols of your genes of interest at hand and not their Entrez Gene ids. `OrgDb` packages use a central gene identifyier (e.g. Entrez Gene id) and contain mappings between this identifier and other kinds of identifiers (e.g. GenBank or Uniprot accession number, RefSeq id, etc.).  
<br>
Because some genes have mutliple symbols. Is is advised to work as long as possible with the unique Entrez Gene ids.  
<br>  
The name of an org package is always of the form `org.<Ab>.<id>.db` (e.g. `org.Hs.eg.db`)  

- `<Ab>` is a 2-letter abbreviation of the organism e.g.: `Hs` for Homo Sapiens.  
- `<id>` is an abbreviation (in lower-case) describing the type of central identifier, e.g.: `eg` for Entrez Gene ids.  

Te `select()` function can be used on these objects in a similar fashion. 
<br>

> **Exericse 19:**  
Find the Entrez Gene Ids for the genes *CD14*, *ZBTB7B*, *SPI1*, *GATA3* and determine whether they are located on chromosome 19. The `org.Hs.eg.db` library has been downloaded and loaded for you. 

```{r q19_orgdb, exercise = T, eval = F}
# What are possible columns to include? 
columns(org.Hs.eg.db)

# character vector of the gene symbols we want to map to entrez gene ids
my_gene_symbols <- c("..", "..", "..", ".")

# map symbols to entrez ids
mappings <- AnnotationDbi::select(.., keys = my_gene_symbols, columns = c("..", "SYMBOL"), keytype = "..")

# look at the output
print(mappings)

# are any of these genes located on chr19?  
mappings$.. %in% ..(txdb)$..
```

```{r q19_orgdb-solution, exercise = T}
# What are possible columns to include? 
columns(org.Hs.eg.db)

# character vector of genes I'm interested in
my_gene_symbols <- c("CD14", "ZBTB7B", "SPI1", "GATA3")

# map symbols to entrez ids
mappings <- AnnotationDbi::select(org.Hs.eg.db, keys = my_gene_symbols, columns = c("ENTREZID", "SYMBOL"), keytype = "SYMBOL")

# look at the output
print(mappings)

# are any of these genes located on chr19?  
mappings$ENTREZID %in% genes(txdb)$GENEID
```
<br>
**Using the `org.Hs.eg.db` package we can go from interesting gene symbols to Entrez Gene identifyers. We use the latter to retrieve their genomic coordinates from `TxDb` and, for example, find chromatin marks covering their promoters. Our ChIP-seq data and the genomic coordinates extracted from the `TxDb` are both stored in `GRanges` objects. To calculate their overlap we can use overlap methods from the `GenomicRanges` package, which we will do now :-).**  
<br>

***
<br>

## 2.5 Quantify overlap among intervals  
### 2.5.1 Overlap with GenomicRanges  
The `GenomicRanges` package has a family of functions to count and identify overlappig intervals: `findOverlaps()`, `coutOverlaps()`, `subsetByOverlaps()`
<br>
`countOverlaps(query, subject)` returns a integer vector with the number of overlaps for each element in the `query`  
<br>
`subsetByOverlaps()` extracts the elements in the `query` that overlap with at least one element in the subject.
<br>
`findOverlaps(query, subject)` returns a `Hits` object containing the index pairings for the overlapping elements. The columns of indices can be accessed through `queryHits(overlap_object)` and `subjectHits(overlap_object)`. If a peak in one of the inputs overlaps with mutiple peaks in the other, its index will appear multiple times in the output. 
<br>
As input we can use `GRanges` and `GRangesLists` objects.  
<br>

### 2.5.2 H3k4me3 in promoters  

> **Exercise 20:**
> What proportion of h3k4me3 peaks are located in promoters?**  
> 
> - define  promoters(txdb_object, upstream = .., downstream = ..)` to extract the genomic locations of promoters  
- Define the promoter as 2000bp upstream and 400bp downstream the TSS.  
- Use the `subsetByOverlaps()` function to extract and count h3k4me3 peaks that overlap with these promoters.   

```{r q20_h3k4me3_pr, exercise = T, eval = F}
# retrieve the promoter regions defined as 2000 bp upstream and 400 bp downstream the TSS  
pr <- ..(txdb, upstream=.., downstream=..)

# h3k4me3 peaks overlapping promoters 
h3k4me3_pr <- ..(mono_h3k4me3, pr)

# proportion of h3k4me3 peaks that show overlap
# divide length of the overlap element, divide by total number of peaks
length(..)/length(..)
```

```{r q20_h3k4me3_pr-solution, exercise = T, eval = T}
# retrieve the promoter regions defined as 2000 bp upstream and 400 bp downstream the TSS  
pr <- promoters(txdb, upstream=2000, downstream=400)

# h3k4me3 peaks overlapping promoters 
h3k4me3_pr <- subsetByOverlaps(mono_h3k4me3, pr)

# proportion of h3k4me3 peaks that show overlap
# divide length of the overlap element, divide by total number of peaks
length(h3k4me3_pr)/length(mono_h3k4me3)
```
<br>
Is this overlap more than expected? 
<br>
To answer this question we can compare the fraction of overlap to the proportion that promoters make up on chr19 with a simple one-proportion z-test.  

- The `reduce()` method will aling the ranges and merge overlapping ranges to produce a simplified set.  

```{r proptest for enrichment in promoters}
# proportion of promoters on chr19 (as bp's)
p0 <- sum(width(reduce(pr)))/seqlengths(txdb)

# proportion of h3k4me3 peaks that overlap with promoters  
prop.test(length(h3k4me3_pr), length(mono_h3k4me3), p = p0, alternative = "greater",
          correct = TRUE)
```
<br>
This is a over-simplified approach that reduces the overlap to points. Better is to bin the genome in equal sized bins and calculate the overlap between bins and peaks or promoters. The resulting contingency table can be used to test whether the two interval datasets are significantly associated.  
<br>

1. Make windows with `tileGenome(seqlengths_object, tilewidth = 200, cut.last.tile.in.chrom =T)` from the  `GenomicRanges` package.  
2. Find overlap between windows and peaks and bins and promoters `subsetbyOverlaps(windows, peaks)`. 
3. Construct your contingency table.  
4. Test with `chisq.test()` or `fisher.test()` in case the expected value in one of the cells is < 5.      

```{r chisqtest for enrichment in promoters}
# make 200bp windows on chr19
# we get the sequence length of chromosome 19 from our txdb object
windows <- tileGenome(seqinfo(txdb), tilewidth = 200, cut.last.tile.in.chrom =T)
names(windows) <- paste("window", 1:length(windows), sep = "_")

# windows that overlap h3k4me3 peaks 
windows_h3k4me3 <- subsetByOverlaps(windows, mono_h3k4me3)

# windows that overlap promoters
windows_pr <- subsetByOverlaps(windows, pr)

# overlapw among these two sets of subsetted windows
windows_h3k4me3_pr <- subsetByOverlaps(windows_h3k4me3, windows_pr)

# construct contingency table
ovl_both <- length(windows_h3k4me3_pr)
ovl_pr_only <- length(windows_pr) - ovl_both
ovl_h3k4me3_only <- length(windows_h3k4me3) - ovl_both
ovl_none <- length(windows) - ovl_both - ovl_pr_only - ovl_h3k4me3_only

h3k4me3_pr_matrix <- matrix(c(ovl_none, ovl_pr_only, ovl_h3k4me3_only, ovl_both), nrow = 2, ncol = 2, 
                            dimnames = list(c("no_overlap_pr","overlap_pr"), c("no_overlap_h3k4me3", "overlap_h3k4me3")))

# chi-square test for independence of two proportions
chisq.test(h3k4me3_pr_matrix)
```
<br>
`r colorize("this is not correct either, tests for whether they are associated, can be more overlapping than expected but also more not-overlapping than expected.", color = "red")`  

### 2.5.3 Overlap H3K4me3 and H3K27ac  
In the genome browser we saw that H3K4me3 and H3K27ac often co-occur. Is this overlap more than expected by chance?  

> **Exercise 21:**  
> Calculate the overlap among H3K4me3 and H3K27ac peaks.  
>
> - Use the `findOverlaps()` function to identify peaks that overlap  
> - Use `queryHits()` and `subjectHits()` to extract their indices and `unique()` to minimize the output to unique peaks  

```{r q19_overlap_h3k4me3_h3k27ac, echo = T, eval = F}
# find overlap between H3K4me3 (query) and H3K27ac (subject)
hits <- ...(mono_h3k4me3, ...)

# print the hits object to examine what it looks like
print(...)

# What is the number of unique H3K4me3 peaks reported in 'hits'?
(h3k4me3_uniq_count <- length(...(...(hits))) )

# what is the number of unique H3K27ac peaks reported in 'hits'?
(h3k27ac_uniq_count <- length(...(...(...))) )
```

```{r q19_overlap_h3k4me3_h3k27ac-solution, echo = T}
# find overlap between H3K4me3 (query) and H3K27ac (subject)
hits <- findOverlaps(mono_h3k4me3, mono_h3k27ac)

# print the hits object to examine what it looks like
print(hits)

# What is the number of unique H3K4me3 peaks reported in 'hits'?
(h3k4me3_uniq_count <- length(unique(queryHits(hits))) )

# what is the number of unique H3K27ac peaks reported in 'hits'?
(h3k27ac_uniq_count <- length(unique(subjectHits(hits))) )
```
<br>
We can plot the overlap with a venn diagram using the `draw.pairwise.venn()` of the `VennDiagram` package. 

> **Exercise 22:** 
> Plot the overlap using `draw.pairwise.venn()`  
>
> * Use the minimum of the two 'unique peak counts' as the number of common peaks  
> * use the `draw.pairwise.venn()` function  
> * for area1, get the number of H3K4me3 peaks `lenght()`  
> * for area2, get the number of H3K27ac peaks `lenght()`  
> * for cross.area, use the number of common peaks 

```{r q22_venn_overlap_h3k4me3_h3k27ac, exercise = T, eval = F}
# Identify the minimum of the two numbers of unique peaks among 
# h3k4me3_uniq_count and h3k27ac_uniq_count 
common_peaks <- min(c(.., ..))

# call a new plotting area
grid.newpage()

# Plot the overlap in a venn diagram
...( 
   area1=...(...),
   area2=...(...), 
   cross.area=..., 
   category=c("H3K4me3", "H3K27ac"), 
   fill=c("red", "gray"), 
   cat.cex=1.2)
```

```{r q22_venn_overlap_h3k4me3_h3k27ac-solution, exercise = T, warning =FALSE}
# Identify the minimum of the two numbers of unique peaks among 
# h3k4me3_uniq_count and h3k27ac_uniq_count 
common_peaks <- min(c(h3k4me3_uniq_count, h3k27ac_uniq_count))

# call a new plotting area
grid.newpage()

# Plot the overlap in a venn diagram
draw.pairwise.venn( 
   area1=length(mono_h3k4me3),
   area2=length(mono_h3k27ac), 
   cross.area=common_peaks, 
   category=c("H3K4me3", "H3K27ac"), 
   fill=c("red", "gray"), 
   cat.cex=1.2)
```
<br>
** *After seeing how these analyses are performed on a small scale. Let's use custom R packages for the analysis of ChIP-seq data that provide us with functions and visualization tools to make several comparisons at the same time. Eg. distribution of a histone mark not over merely promoters but over several genomic elements.* **    

## 2.6 Using custsom ChIP-seq packages  
We will explore the ChIPpeakAnno and genomation packages.  

### 2.6.1 Overlap with ChIPpeakAnno  
### 2.6.1.1 Overlap with genomic features  
The  `assignChromosomeRegion()` function can be used to summarize the distribution of peaks over different type of features such as exon, intron, enhancer, proximal promoter, 5’ UTR and 3’ UTR. 
<br>
A peak will frequently overlap with multiple annotations, the parameter `precedence` is designed to avoiding double count for annotations. If no `precedence` specified, when a peak overlaps with both promoter and 5'UTR, both promoter and 5'UTR will be incremented. If a `precedence` is specified and if, for example if promoter is specified *before* 5'UTR, then only promoter will be incremented for the same example.  
<br>
Alternatively, we can set `nucleotideLevel = TRUE`. This will give a nucleotide level distribution over different features.
<br>
```{r chippeakanno genomic feature overlap }
# assign peaks to chromosomal regions:
chrom_region_h3k4me3 <-assignChromosomeRegion(mono_h3k4me3, nucleotideLevel=TRUE, precedence=c("Promoters", "immediateDownstream","fiveUTRs", "threeUTRs", "Exons", "Introns"), TxDb=txdb)

# Plot the distribution as barplot
barplot(chrom_region_h3k4me3$percentage, las = 2, 
        main = "H3K4me3 distribution among genome features",
        ylab = "H3K4me3 peaks (% )")
pie(chrom_region_h3k4me3$percentage, main = "H3K4me3 distribution among genome features")
```

### 2.6.1.2 Overlap among marks   


use `annotatePeakInBatch` to annotate the overlapping peaks with the genomic features in the AnnotationData within certain distance away specified by maxgap, which is 5kb in the following example.

### 2.6.3 Overlap with Genomation  
intersect.chr = TRUE -- will limit the analysis only to the chromosomes that are present in both data sets.

```{r genomation, eval =FALSE}
# readTranscriptFeatures reads a bed12 formatted file and parses the coordinates into a GRangesList containing four elements: exons, introns. promoters and transcription start sites (TSSes).
gencode32 <- readTranscriptFeatures("data/blueprint/gencodev32.bed")

# individual annotations
annot_h3k4me3 <- annotateWithGeneParts(mono_h3k4me3, gencode32, intersect.chr = TRUE)
plotTargetAnnotation(annot_h3k4me3, main = "Monocytes - H3K4me3")

annot_h3k36me3 <- annotateWithGeneParts(mono_h3k36me3, gencode32, intersect.chr = TRUE)
plotTargetAnnotation(annot_h3k36me3, main = "Monocytes - H3K36me3")

annot_h3k4me1 <- annotateWithGeneParts(mono_h3k4me1, gencode32, intersect.chr = TRUE)
plotTargetAnnotation(annot_h3k4me3, main = "Monocytes - H3K4me1")

annot_h3k27me3 <- annotateWithGeneParts(mono_h3k27me3, gencode32, intersect.chr = TRUE)
plotTargetAnnotation(annot_h3k27me3, main = "Monocytes - H3K27me3")

# list based annotation 
annot_list <- annotateWithFeatures(mono_list, gencode32, intersect.chr = TRUE)
```

<br>

***
<br>






### 




### 2.5.4 H3K4me3 at promoters   


### 2.5.5 H3K4me3 distribution across different elements  
chippeakanno function

For more categories, the `UpSetR` package provides an effective plot: the `upset plot` [Lex & Gehlenbor, 2014, Nat methods](https://doi.org/10.1038/nmeth.3033).  





<br>

***
<br>


Counting overlap and non-overlap     

- `countOverlaps(query, subject)`  
- `findOverlaps(query, subject)`  
- `subsetByOverlap(query, subject)`  


## 2.8 Use custom ChIPs-eq analysis packages eg `ChIPpeakAnno` or `ChIPSeeker` package to count and visualize distribution of peaks  
  
  * overview of ChIP-seq analysis with candidate r/Bioconductor packages  
  * `ChIPSeeker` works on BED files. `ChIPpeakAnno`
  * Example 1: overlap/occurence in genomic regions: in exon, intron, enhancer, proximal promoter, 5’ UTR and 3’ UTR  
  * Statistics: is mark enriched in a particular region compared to background/genomic distribution?  
  * Repeat this for another mark.  
  * Example 2: distance to TSS and annotate peaks to genes (with limit on distance to TSS)  
  * Example 3: 

## 2.9 Examining enrichment near TSS: heatmap and average profile plot    
- enrichment near TSS
- H3K27me3 distribution across the gene body
  + subset genes based on gene expression 

## 2.9 Extracting peaks or genes  


## 2.10 References   
Material used to compile this tutorial:  

Title | Author(s) | Date published or last updated | Date visited | Ref/Link  
-- | -- | -- | -- | --    
An Introduction to the GenomicRanges Package | Marc Carlson, Patrick Aboyoun, Hervé Pagès, and Martin Morgan | 2020-10-27 | 2020-11-04 | [link](https://bioconductor.org/packages/release/bioc/vignettes/GenomicRanges/inst/doc/GenomicRangesIntroduction.html)   
Bioconductor 2018 Workshops - 4 GenomicRanges | Michael Lawrence | 2018-07-30 | 2020-11-04 | [link](https://bioconductor.github.io/BiocWorkshops/solving-common-bioinformatic-challenges-using-genomicranges.html)    
Computational Genomics with R, Chapter 6 | Altuna Akalin | 2020-09-30 | 2020-11-05 | [link](http://compgenomr.github.io/book/genomicIntervals.html)    
ChIP-seq data analysis in R | Jonas Ibn-Salem (JGU/IMB Mainz) | 2016-03-03 | 2020-11-05 |  [link](http://cbdm-01.zdv.uni-mainz.de/~jibnsale/teaching/chip-seq_exercises.html#download-and-parse-input-data)   
Making and Utilizing TxDb Objects | Marc Carlson, Patrick Aboyoun, Hervé Pagès, Seth Falcon, and Martin Morgan | 2020-10-27 | 2020-11-05 | [link](https://bioconductor.org/packages/release/bioc/vignettes/GenomicFeatures/inst/doc/GenomicFeatures.pdf)  


